<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>Smart Traffic Junction Demo</title>
  <style>
    body { font-family: system-ui, Arial, sans-serif; margin: 16px; background:#0b0f1a; color:#e8eefc; }
    .top { display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin-bottom:12px; }
    button, select, input { background:#1b2750; border:1px solid #2b3a68; color:#e8eefc; padding:8px 10px; border-radius:10px; cursor:pointer; }
    button:hover { background:#25346a; }
    .card { background:#121a2e; border:1px solid #223055; border-radius:14px; padding:12px; box-shadow:0 6px 20px rgba(0,0,0,0.25); }
    .row { display:flex; gap:12px; flex-wrap:wrap; }
    .small { font-size:12px; color:#b6c4ee; }
    .pill { display:inline-block; padding:2px 8px; border-radius:999px; font-size:12px; border:1px solid #2b3a68; }
    .pill.green { background: rgba(45, 200, 90, 0.15); border-color: rgba(45, 200, 90, 0.35); }
    .pill.red { background: rgba(220, 70, 70, 0.15); border-color: rgba(220, 70, 70, 0.35); }

    .vizWrap { width: 980px; max-width:100%; }
    canvas { width:100%; height:auto; display:block; border-radius:16px; border:1px solid #223055; }

    .hud { display:flex; justify-content:space-between; align-items:center; margin-bottom:10px; flex-wrap:wrap; gap:10px; }
    .stats { display:grid; grid-template-columns: repeat(4, minmax(120px,1fr)); gap:8px; width:100%; margin-top:10px; }
    .stat { background: rgba(255,255,255,0.04); border:1px solid rgba(255,255,255,0.06); padding:10px; border-radius:12px; }
    .stat b { display:block; font-size:14px; }
  </style>
</head>

<body>
  <h2 style="margin:0 0 10px 0;">Single Smart Junction Traffic Optimizer</h2>

  <div class="top card">
    <button id="btnStart">Start</button>
    <button id="btnPause">Pause</button>
    <button id="btnReset">Reset</button>

    <span class="small">Mode:</span>
    <select id="mode">
      <option value="dynamic">Dynamic (Optimized)</option>
      <option value="fixed">Fixed (Baseline)</option>
    </select>

    <span class="small">Scenario:</span>
    <select id="scenario">
      <option value="normal">Normal</option>
      <option value="morning_peak">Morning Peak</option>
      <option value="evening_peak">Evening Peak</option>
      <option value="accident_eastbound">Accident (Eastbound)</option>
    </select>

    <label class="small"><input type="checkbox" id="autoEvents" checked/> Auto Events</label>

    <span class="small">Inject at:</span>
    <select id="injWhere">
      <option value="N">North</option>
      <option value="S">South</option>
      <option value="E">East</option>
      <option value="W">West</option>
    </select>

    <button id="btnEmergency">Emergency</button>
    <button id="btnPedNS">Pedestrian (NS)</button>
    <button id="btnPedEW">Pedestrian (EW)</button>

    <span id="status" class="small">Connecting…</span>
  </div>

  <div class="row">
    <div class="card vizWrap">
      <div class="hud">
        <div>
          <div><b>Intersection A (Single Junction View)</b></div>
          <div class="small" id="phaseLine">Phase: -</div>
        </div>
        <div><span id="badge" class="pill green">dynamic</span></div>
      </div>

      <canvas id="junctionCanvas" width="1000" height="600"></canvas>

      <div class="stats">
        <div class="stat"><b id="qN">N-IN: 0</b><span class="small">cars waiting</span></div>
        <div class="stat"><b id="qS">S-IN: 0</b><span class="small">cars waiting</span></div>
        <div class="stat"><b id="qE">E-IN: 0</b><span class="small">cars waiting</span></div>
        <div class="stat"><b id="qW">W-IN: 0</b><span class="small">cars waiting</span></div>
      </div>

      <div class="small" id="reasonLine" style="margin-top:10px;">Reason: -</div>
    </div>
  </div>

<script>
/* =========================================================
   Backend config
========================================================= */
const API = "http://localhost:8000";
let timer = null;
let currentMode = "dynamic";

/* Must match backend config.py */
const YELLOW_SEC = 2;
const ALL_RED_SEC = 1;

/* =========================================================
   Canvas setup
========================================================= */
const canvas = document.getElementById("junctionCanvas");
const ctx = canvas.getContext("2d");

function resizeCanvasToDisplaySize() {
  const rect = canvas.getBoundingClientRect();
  const dpr = window.devicePixelRatio || 1;
  const w = Math.floor(rect.width * dpr);
  const h = Math.floor((rect.width * 0.6) * dpr);
  if (canvas.width !== w || canvas.height !== h) {
    canvas.width = w;
    canvas.height = h;
  }
}
window.addEventListener("resize", resizeCanvasToDisplaySize);
resizeCanvasToDisplaySize();

/* =========================================================
   Visual simulation state (frontend-only)
========================================================= */
const VIS = {
  inter: null,
  cars: { N: [], S: [], E: [], W: [] },
  lastTs: performance.now(),
  maxCarsPerDir: 30,

  spacing: 32,
  followSpeed: 260,
  passAdvance: 30,

  carLen: 30,
  carWid: 16,

  flowOffset: { N:0, S:0, E:0, W:0 },

  emergency: {
    activeDir: null,      // "N"|"S"|"E"|"W"|null
    allRedUntilMs: 0,
  }
};

function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }

function pickCarColor() {
  const colors = ["#6aa5ff","#2dd05a","#ff6b6b","#ffd166","#a78bfa","#22d3ee"];
  return colors[Math.floor(Math.random()*colors.length)];
}

function makeCar(dir, lane) {
  return { dir, lane, x:0, y:0, color: pickCarColor() };
}

/* =========================================================
   Emergency detection (from backend)
========================================================= */
function getEmergencyDir(inter){
  if (!inter || !inter.emergency) return null;
  for (const k of Object.keys(inter.emergency)) {
    if (inter.emergency[k]) return k;
  }
  return null;
}

function emergencyAxis(dir){
  if (!dir) return null;
  return (dir === "N" || dir === "S") ? "NS" : "EW";
}

/* =========================================================
   Traffic light state: green / yellow / red + emergency override
========================================================= */
function baseLightStateForAxis(axis, inter){
  if (!inter) return "red";

  if (!inter.in_transition) {
    return (inter.phase === axis) ? "green" : "red";
  }

  const tr = Number(inter.transition_left ?? 0);
  if (tr > ALL_RED_SEC) return "yellow";
  return "red";
}

/**
 * Emergency override:
 * - Emergency start -> show ALL RED for ALL_RED_SEC (visual clearance)
 * - Then show GREEN only on emergency axis, other axis RED
 * - If backend is still in_transition, keep RED (smoother & accurate)
 */
function lightStateForAxis(axis, inter){
  const now = performance.now();
  const edir = VIS.emergency.activeDir;

  if (edir) {
    if (!inter) return "red";

    // if backend is still transitioning, stay red
    if (inter.in_transition) return "red";

    // clearance all-red window
    if (now < VIS.emergency.allRedUntilMs) return "red";

    // after clearance: only emergency axis green
    const eAxis = emergencyAxis(edir);
    return (axis === eAxis) ? "green" : "red";
  }

  return baseLightStateForAxis(axis, inter);
}

function isGreen(dir, inter) {
  if (VIS.emergency.activeDir) {
    const axis = emergencyAxis(VIS.emergency.activeDir);
    return (axis === "NS" && (dir === "N" || dir === "S")) ||
           (axis === "EW" && (dir === "E" || dir === "W"));
  }

  if (!inter) return false;
  if (inter.in_transition) return false;
  if ((dir === "N" || dir === "S") && inter.phase === "NS") return true;
  if ((dir === "E" || dir === "W") && inter.phase === "EW") return true;
  return false;
}

/* =========================================================
   Road geometry (lane centers prevent overlap)
========================================================= */
function roadGeom(){
  const W = canvas.width, H = canvas.height;
  const cx = W/2, cy = H/2;
  const roadW = Math.min(W,H) * 0.26;
  const laneSep = roadW * 0.18;
  const stopDist = roadW * 0.55;
  return {W,H,cx,cy,roadW,laneSep,stopDist};
}

function laneCenter(dir, lane){
  const {cx,cy,laneSep} = roadGeom();
  const s = (lane === 0 ? -laneSep : +laneSep);

  if (dir === "N" || dir === "S") return { x: cx + s, y: null };
  if (dir === "E" || dir === "W") return { x: null, y: cy + s };
  return {x:cx,y:cy};
}

function stopLine(dir, lane) {
  const {cx,cy,stopDist} = roadGeom();
  const lc = laneCenter(dir, lane);

  if (dir === "N") return { x: lc.x, y: cy - stopDist };
  if (dir === "S") return { x: lc.x, y: cy + stopDist };
  if (dir === "E") return { x: cx + stopDist, y: lc.y };
  return { x: cx - stopDist, y: lc.y };
}

function placeCarAtBack(car, dir, indexInLane) {
  const {W,H,cx,cy} = roadGeom();
  const s = VIS.spacing;
  const far = 0.48;

  if (dir === "N") { car.x = laneCenter(dir, car.lane).x; car.y = (cy - H*far) + indexInLane*s; }
  if (dir === "S") { car.x = laneCenter(dir, car.lane).x; car.y = (cy + H*far) - indexInLane*s; }
  if (dir === "E") { car.y = laneCenter(dir, car.lane).y; car.x = (cx + W*far) - indexInLane*s; }
  if (dir === "W") { car.y = laneCenter(dir, car.lane).y; car.x = (cx - W*far) + indexInLane*s; }
}

/* =========================================================
   Reconcile cars with backend queues
========================================================= */
function reconcileCars(inter) {
  if (!inter) return;
  const q = inter.queues;

  ["N","S","E","W"].forEach(dir => {
    const target = clamp(q[dir], 0, VIS.maxCarsPerDir);
    const arr = VIS.cars[dir];

    while (arr.length < target) {
      const lane = (arr.length % 2);
      const c = makeCar(dir, lane);
      const idxLane = Math.floor(arr.length / 2);
      placeCarAtBack(c, dir, idxLane);
      arr.push(c);
    }

    while (arr.length > target) arr.pop();
  });
}

/* =========================================================
   Movement
========================================================= */
function updateFlowOffset(dt, inter) {
  ["N","S","E","W"].forEach(dir => {
    if (isGreen(dir, inter)) {
      VIS.flowOffset[dir] += VIS.passAdvance * dt;
    } else {
      VIS.flowOffset[dir] *= 0.80;
      if (Math.abs(VIS.flowOffset[dir]) < 0.3) VIS.flowOffset[dir] = 0;
    }
    VIS.flowOffset[dir] = clamp(VIS.flowOffset[dir], 0, VIS.spacing);
  });
}

function targetPosition(dir, lane, orderInLane) {
  const stop = stopLine(dir, lane);
  let tx = stop.x, ty = stop.y;
  const off = VIS.flowOffset[dir];

  if (dir === "N") { ty -= orderInLane * VIS.spacing; ty += off; }
  if (dir === "S") { ty += orderInLane * VIS.spacing; ty -= off; }
  if (dir === "E") { tx += orderInLane * VIS.spacing; tx -= off; }
  if (dir === "W") { tx -= orderInLane * VIS.spacing; tx += off; }

  return {tx, ty};
}

function moveToward(car, tx, ty, speed, dt) {
  const dx = tx - car.x;
  const dy = ty - car.y;
  const d = Math.hypot(dx,dy) || 1;
  const step = Math.min(d, speed * dt);
  car.x += (dx/d) * step;
  car.y += (dy/d) * step;
}

function updateCars(dt, inter) {
  if (!inter) return;

  updateFlowOffset(dt, inter);

  ["N","S","E","W"].forEach(dir => {
    const lane0 = VIS.cars[dir].filter(c => c.lane === 0);
    const lane1 = VIS.cars[dir].filter(c => c.lane === 1);

    const stop0 = stopLine(dir, 0);
    const stop1 = stopLine(dir, 1);

    lane0.sort((a,b)=>Math.hypot(a.x-stop0.x,a.y-stop0.y)-Math.hypot(b.x-stop0.x,b.y-stop0.y));
    lane1.sort((a,b)=>Math.hypot(a.x-stop1.x,a.y-stop1.y)-Math.hypot(b.x-stop1.x,b.y-stop1.y));

    for (let i=0;i<lane0.length;i++){
      const {tx,ty} = targetPosition(dir, 0, i);
      moveToward(lane0[i], tx, ty, VIS.followSpeed, dt);
    }
    for (let i=0;i<lane1.length;i++){
      const {tx,ty} = targetPosition(dir, 1, i);
      moveToward(lane1[i], tx, ty, VIS.followSpeed, dt);
    }
  });
}

/* =========================================================
   Drawing
========================================================= */
function roundRect(c, x, y, w, h, r) {
  c.beginPath();
  c.moveTo(x+r, y);
  c.arcTo(x+w, y,   x+w, y+h, r);
  c.arcTo(x+w, y+h, x,   y+h, r);
  c.arcTo(x,   y+h, x,   y,   r);
  c.arcTo(x,   y,   x+w, y,   r);
  c.closePath();
}

function drawRoads() {
  const {W,H,cx,cy,roadW,laneSep,stopDist} = roadGeom();

  ctx.fillStyle = "#0b0f1a";
  ctx.fillRect(0,0,W,H);

  ctx.fillStyle = "#0e152c";
  ctx.strokeStyle = "rgba(120,150,240,0.25)";
  ctx.lineWidth = 2;

  ctx.beginPath();
  roundRect(ctx, cx - W*0.48, cy - roadW/2, W*0.96, roadW, 18);
  ctx.fill(); ctx.stroke();

  ctx.beginPath();
  roundRect(ctx, cx - roadW/2, cy - H*0.48, roadW, H*0.96, 18);
  ctx.fill(); ctx.stroke();

  ctx.setLineDash([10,10]);
  ctx.strokeStyle = "rgba(160,190,255,0.22)";
  ctx.lineWidth = 2;

  ctx.beginPath(); ctx.moveTo(cx - W*0.48, cy); ctx.lineTo(cx + W*0.48, cy); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(cx, cy - H*0.48); ctx.lineTo(cx, cy + H*0.48); ctx.stroke();

  ctx.beginPath(); ctx.moveTo(cx - W*0.48, cy - laneSep); ctx.lineTo(cx + W*0.48, cy - laneSep); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(cx - W*0.48, cy + laneSep); ctx.lineTo(cx + W*0.48, cy + laneSep); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(cx - laneSep, cy - H*0.48); ctx.lineTo(cx - laneSep, cy + H*0.48); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(cx + laneSep, cy - H*0.48); ctx.lineTo(cx + laneSep, cy + H*0.48); ctx.stroke();

  ctx.setLineDash([]);

  ctx.strokeStyle = "rgba(240,250,255,0.35)";
  ctx.lineWidth = 4;

  ctx.beginPath(); ctx.moveTo(cx-roadW/2, cy-stopDist); ctx.lineTo(cx+roadW/2, cy-stopDist); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(cx-roadW/2, cy+stopDist); ctx.lineTo(cx+roadW/2, cy+stopDist); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(cx-stopDist, cy-roadW/2); ctx.lineTo(cx-stopDist, cy+roadW/2); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(cx+stopDist, cy-roadW/2); ctx.lineTo(cx+stopDist, cy+roadW/2); ctx.stroke();
}

function drawLights(inter) {
  if (!inter) return;
  const {cx,cy,stopDist} = roadGeom();

  const nsState = lightStateForAxis("NS", inter);
  const ewState = lightStateForAxis("EW", inter);

  function colorFor(state){
    if (state === "green") return "#2dd05a";
    if (state === "yellow") return "#ffd166";
    return "#dc4646";
  }

  function bulb(x,y,state){
    ctx.fillStyle = colorFor(state);
    ctx.beginPath(); ctx.arc(x,y,12,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle="rgba(0,0,0,0.45)";
    ctx.lineWidth=2; ctx.stroke();
  }

  bulb(cx, cy - stopDist*0.72, nsState);
  bulb(cx, cy + stopDist*0.72, nsState);
  bulb(cx + stopDist*0.72, cy, ewState);
  bulb(cx - stopDist*0.72, cy, ewState);

  const edir = VIS.emergency.activeDir;
  ctx.fillStyle="#e8eefc";
  ctx.font = `${Math.floor(16*(canvas.width/1000))}px system-ui`;

  if (edir) {
    ctx.fillText(`EMERGENCY ${edir} | Override active`, 18, 30);
  } else {
    ctx.fillText(`NS: ${nsState.toUpperCase()}  |  EW: ${ewState.toUpperCase()}`, 18, 30);
  }
}

function drawCarSprite(car, emergencyDir) {
  const w = VIS.carLen * (canvas.width/1000);
  const h = VIS.carWid * (canvas.width/1000);

  let ang = 0;
  if (car.dir === "N") ang = Math.PI/2;
  if (car.dir === "S") ang = -Math.PI/2;
  if (car.dir === "E") ang = Math.PI;
  if (car.dir === "W") ang = 0;

  const isEmer = (emergencyDir === car.dir);

  ctx.save();
  ctx.translate(car.x, car.y);
  ctx.rotate(ang);

  ctx.fillStyle = "rgba(0,0,0,0.25)";
  roundRect(ctx, -w/2+2, -h/2+2, w, h, 5);
  ctx.fill();

  ctx.fillStyle = isEmer ? "#ffd166" : car.color;
  roundRect(ctx, -w/2, -h/2, w, h, 5);
  ctx.fill();

  ctx.fillStyle = "rgba(10,20,40,0.65)";
  roundRect(ctx, -w/2+6, -h/2+3, w-12, h-6, 3);
  ctx.fill();

  ctx.restore();
}

function drawCars(inter) {
  const emergencyDir = getEmergencyDir(inter);
  ["N","S","E","W"].forEach(dir => {
    for (const car of VIS.cars[dir]) drawCarSprite(car, emergencyDir);
  });
}

function renderFrame(ts) {
  resizeCanvasToDisplaySize();
  const dt = Math.min(0.05, (ts - VIS.lastTs) / 1000);
  VIS.lastTs = ts;

  drawRoads();
  if (VIS.inter) {
    updateCars(dt, VIS.inter);
    drawLights(VIS.inter);
    drawCars(VIS.inter);
  }
  requestAnimationFrame(renderFrame);
}
requestAnimationFrame(renderFrame);

function updateFromBackend(intersectionSnapshot) {
  const newDir = getEmergencyDir(intersectionSnapshot);
  const oldDir = VIS.emergency.activeDir;

  if (newDir && !oldDir) {
    VIS.emergency.activeDir = newDir;
    VIS.emergency.allRedUntilMs = performance.now() + (ALL_RED_SEC * 1000);
  } else if (!newDir && oldDir) {
    VIS.emergency.activeDir = null;
    VIS.emergency.allRedUntilMs = 0;
  } else if (newDir && oldDir && newDir !== oldDir) {
    VIS.emergency.activeDir = newDir;
    VIS.emergency.allRedUntilMs = performance.now() + (ALL_RED_SEC * 1000);
  }

  VIS.inter = intersectionSnapshot;
  reconcileCars(VIS.inter);
}

/* =========================================================
   API + UI
========================================================= */
async function api(method, path, body=null) {
  const opts = { method, headers: {"Content-Type":"application/json"} };
  if (body) opts.body = JSON.stringify(body);
  const res = await fetch(`${API}${path}`, opts);
  return await res.json();
}

async function tickOnce() {
  const data = await api("POST","/tick");
  const sim = (currentMode === "fixed") ? data.fixed : data.dynamic;

  const A = sim.intersections.find(x => x.id === "A") || sim.intersections[0];
  const q = A.queues;

  document.getElementById("status").textContent =
    `t=${sim.t}s | scenario=${sim.scenario} | running=${data.running}`;

  document.getElementById("badge").textContent = currentMode;
  document.getElementById("badge").className = "pill " + (currentMode==="dynamic" ? "green":"red");

  document.getElementById("phaseLine").textContent =
    `Phase: ${A.phase} | time left: ${A.time_left}s ${A.in_transition ? "(transition)" : ""}` +
    (A.in_transition ? ` | transition_left: ${A.transition_left ?? "-"}` : "");

  document.getElementById("reasonLine").textContent = `Reason: ${A.reason || "-"}`;

  // ✅ safer queue access
  document.getElementById("qN").textContent = `N-IN: ${q["N"]}`;
  document.getElementById("qS").textContent = `S-IN: ${q["S"]}`;
  document.getElementById("qE").textContent = `E-IN: ${q["E"]}`;
  document.getElementById("qW").textContent = `W-IN: ${q["W"]}`;

  updateFromBackend(A);
}

function startLoop() {
  if (timer) return;
  timer = setInterval(tickOnce, 900);
}
function stopLoop() {
  if (!timer) return;
  clearInterval(timer);
  timer = null;
}

document.getElementById("btnStart").onclick = async () => {
  await api("POST","/control",{running:true});
  startLoop();
};

document.getElementById("btnPause").onclick = async () => {
  await api("POST","/control",{running:false});
  stopLoop();
  await tickOnce();
};

document.getElementById("btnReset").onclick = async () => {
  await api("POST","/control",{seed: 42});
  await tickOnce();
};

document.getElementById("mode").onchange = async (e) => {
  currentMode = e.target.value;
  await tickOnce();
};

document.getElementById("scenario").onchange = async (e) => {
  await api("POST","/control",{scenario: e.target.value});
  await tickOnce();
};

document.getElementById("autoEvents").onchange = async (e) => {
  await api("POST","/control",{auto_events: e.target.checked});
};

document.getElementById("btnEmergency").onclick = async () => {
  const where = document.getElementById("injWhere").value;
  await api("POST","/inject",{intersection_id:"A", kind:"emergency", where});
  await tickOnce();
};

document.getElementById("btnPedNS").onclick = async () => {
  await api("POST","/inject",{intersection_id:"A", kind:"ped", where:"NS"});
  await tickOnce();
};

document.getElementById("btnPedEW").onclick = async () => {
  await api("POST","/inject",{intersection_id:"A", kind:"ped", where:"EW"});
  await tickOnce();
};

// initial paint
(async () => {
  try {
    await api("GET","/health");
    await tickOnce();
  } catch(e) {
    document.getElementById("status").textContent = "Backend not running on 8000.";
  }
})();
</script>
</body>
</html>
