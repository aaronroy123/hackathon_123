<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>Smart Traffic Junction Demo</title>
  <style>
    body { font-family: system-ui, Arial, sans-serif; margin: 16px; background:#0b0f1a; color:#e8eefc; }
    .top { display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin-bottom:12px; }
    button, select, input { background:#1b2750; border:1px solid #2b3a68; color:#e8eefc; padding:8px 10px; border-radius:10px; cursor:pointer; }
    button:hover { background:#25346a; }
    button:disabled { opacity:0.45; cursor:not-allowed; }
    .card { background:#121a2e; border:1px solid #223055; border-radius:14px; padding:12px; box-shadow:0 6px 20px rgba(0,0,0,0.25); }
    .row { display:flex; gap:12px; flex-wrap:wrap; }
    .small { font-size:12px; color:#b6c4ee; }
    .pill { display:inline-block; padding:2px 8px; border-radius:999px; font-size:12px; border:1px solid #2b3a68; }
    .pill.green { background: rgba(45, 200, 90, 0.15); border-color: rgba(45, 200, 90, 0.35); }
    .pill.red { background: rgba(220, 70, 70, 0.15); border-color: rgba(220, 70, 70, 0.35); }

    .vizWrap { width: 980px; max-width:100%; }
    canvas { width:100%; height:auto; display:block; border-radius:16px; border:1px solid #223055; }

    .hud { display:flex; justify-content:space-between; align-items:center; margin-bottom:10px; flex-wrap:wrap; gap:10px; }
    .stats { display:grid; grid-template-columns: repeat(4, minmax(120px,1fr)); gap:8px; width:100%; margin-top:10px; }
    .stat { background: rgba(255,255,255,0.04); border:1px solid rgba(255,255,255,0.06); padding:10px; border-radius:12px; }
    .stat b { display:block; font-size:14px; }
  </style>
</head>

<body>
  <h2 style="margin:0 0 10px 0;">Single Smart Junction Traffic Optimizer</h2>

  <div class="top card">
    <button id="btnStart">Start</button>
    <button id="btnPause">Pause</button>
    <button id="btnReset">Reset</button>

    <span class="small">Mode:</span>
    <select id="mode">
      <option value="dynamic">Dynamic (Optimized)</option>
      <option value="fixed">Fixed (Baseline)</option>
    </select>

    <span class="small">Scenario:</span>
    <select id="scenario">
      <option value="normal">Normal</option>
      <option value="morning_peak">Morning Peak</option>
      <option value="evening_peak">Evening Peak</option>
      <option value="accident_eastbound">Accident (Eastbound)</option>
    </select>

    <label class="small"><input type="checkbox" id="autoEvents" checked/> Auto Events</label>

    <button id="btnEmergency">Emergency (Alt NS/EW)</button>
    <button id="btnPedNS">Pedestrian (NS)</button>
    <button id="btnPedEW">Pedestrian (EW)</button>

    <span id="status" class="small">Connecting…</span>
  </div>

  <div class="row">
    <div class="card vizWrap">
      <div class="hud">
        <div>
          <div><b>Intersection A (Single Junction View)</b></div>
          <div class="small" id="phaseLine">Phase: -</div>
        </div>
        <div><span id="badge" class="pill green">dynamic</span></div>
      </div>

      <canvas id="junctionCanvas" width="1000" height="600"></canvas>

      <div class="stats">
        <div class="stat"><b id="qN">N-IN: 0</b><span class="small">cars waiting</span></div>
        <div class="stat"><b id="qS">S-IN: 0</b><span class="small">cars waiting</span></div>
        <div class="stat"><b id="qE">E-IN: 0</b><span class="small">cars waiting</span></div>
        <div class="stat"><b id="qW">W-IN: 0</b><span class="small">cars waiting</span></div>
      </div>

      <div class="small" id="reasonLine" style="margin-top:10px;">Reason: -</div>
    </div>
  </div>

<script>
/* =========================================================
   Backend config
========================================================= */
const API = "http://localhost:8000";
let timer = null;
let currentMode = "dynamic";

/* Must match backend config.py */
const YELLOW_SEC = 2;
const ALL_RED_SEC = 1;

/* =========================================================
   Canvas setup
========================================================= */
const canvas = document.getElementById("junctionCanvas");
const ctx = canvas.getContext("2d");

function resizeCanvasToDisplaySize() {
  const rect = canvas.getBoundingClientRect();
  const dpr = window.devicePixelRatio || 1;
  const w = Math.floor(rect.width * dpr);
  const h = Math.floor((rect.width * 0.6) * dpr);
  if (canvas.width !== w || canvas.height !== h) {
    canvas.width = w;
    canvas.height = h;
  }
}
window.addEventListener("resize", resizeCanvasToDisplaySize);
resizeCanvasToDisplaySize();

/* =========================================================
   Visual simulation state (LEFT LANE ONLY)
========================================================= */
const VIS = {
  inter: null,
  cars: { N: [], S: [], E: [], W: [] }, // each dir contains both waiting + leaving cars
  lastTs: performance.now(),
  maxCarsPerDir: 80,

  spacing: 36,
  carLen: 30,
  carWid: 16,

  followSpeed: 340,
  passSpeed: 520,  // speed when leaving through the junction
  passAdvance: 44,

  flowOffset: { N:0, S:0, E:0, W:0 },

  nextId: 1,

  // track last backend queue to detect "served" drops
  lastBackendQ: { N:0, S:0, E:0, W:0 },

  emergency: {
    active: false,
    axis: null,
    untilMs: 0,
    nextAxis: "NS",
    amb: null
  }
};

function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }

function pickCarColor() {
  const colors = ["#6aa5ff","#2dd05a","#ff6b6b","#ffd166","#a78bfa","#22d3ee"];
  return colors[Math.floor(Math.random()*colors.length)];
}

/* =========================================================
   Road geometry + LEFT LANE rule
========================================================= */
function roadGeom(){
  const W = canvas.width, H = canvas.height;
  const cx = W/2, cy = H/2;
  const roadW = Math.min(W,H) * 0.26;
  const laneSep = roadW * 0.18;
  const stopDist = roadW * 0.55;
  return {W,H,cx,cy,roadW,laneSep,stopDist};
}

/**
 * ✅ LEFT lane rule relative to direction of travel
 */
function laneCenter(dir, lane){
  const {cx,cy,laneSep} = roadGeom();
  const left = (lane === 0);

  if (dir === "N") { // moving down, left is +x
    const s = left ? +laneSep : -laneSep;
    return { x: cx + s, y: null };
  }
  if (dir === "S") { // moving up, left is -x
    const s = left ? -laneSep : +laneSep;
    return { x: cx + s, y: null };
  }
  if (dir === "E") { // moving left, left is +y
    const s = left ? +laneSep : -laneSep;
    return { x: null, y: cy + s };
  }
  if (dir === "W") { // moving right, left is -y
    const s = left ? -laneSep : +laneSep;
    return { x: null, y: cy + s };
  }
  return {x:cx,y:cy};
}

function stopLine(dir, lane) {
  const {cx,cy,stopDist} = roadGeom();
  const lc = laneCenter(dir, lane);

  if (dir === "N") return { x: lc.x, y: cy - stopDist };
  if (dir === "S") return { x: lc.x, y: cy + stopDist };
  if (dir === "E") return { x: cx + stopDist, y: lc.y };
  return { x: cx - stopDist, y: lc.y };
}

function exitPoint(dir){
  const {W,H,cx,cy} = roadGeom();
  const farX = W*0.60, farY = H*0.60;
  const lane = 0;

  if (dir === "N") return { x: laneCenter("N", lane).x, y: cy + farY };
  if (dir === "S") return { x: laneCenter("S", lane).x, y: cy - farY };
  if (dir === "E") return { x: cx - farX, y: laneCenter("E", lane).y };
  return { x: cx + farX, y: laneCenter("W", lane).y };
}

function placeCarAtBack(car) {
  const {W,H,cx,cy} = roadGeom();
  const far = 0.56;

  const i = car.laneIndex;
  const s = VIS.spacing;

  if (car.dir === "N") { car.x = laneCenter("N", car.lane).x; car.y = (cy - H*far) + i*s; }
  if (car.dir === "S") { car.x = laneCenter("S", car.lane).x; car.y = (cy + H*far) - i*s; }
  if (car.dir === "E") { car.y = laneCenter("E", car.lane).y; car.x = (cx + W*far) - i*s; }
  if (car.dir === "W") { car.y = laneCenter("W", car.lane).y; car.x = (cx - W*far) + i*s; }
}

/* =========================================================
   Emergency visuals (unchanged)
========================================================= */
function beginEmergency(axis){
  VIS.emergency.active = true;
  VIS.emergency.axis = axis;
  VIS.emergency.untilMs = performance.now() + 5200;

  const {W,H,cx,cy} = roadGeom();
  const farX = W*0.52, farY = H*0.52;

  let dir;
  if (axis === "NS") dir = (Math.random() < 0.5) ? "N" : "S";
  else dir = (Math.random() < 0.5) ? "W" : "E";

  const lane = 0;
  const amb = { type:"ambulance", dir, lane, x:cx, y:cy };

  if (dir === "N") { amb.x = laneCenter("N", lane).x; amb.y = cy - farY; }
  if (dir === "S") { amb.x = laneCenter("S", lane).x; amb.y = cy + farY; }
  if (dir === "E") { amb.y = laneCenter("E", lane).y; amb.x = cx + farX; }
  if (dir === "W") { amb.y = laneCenter("W", lane).y; amb.x = cx - farX; }

  VIS.emergency.amb = amb;
}
function endEmergency(){
  VIS.emergency.active = false;
  VIS.emergency.axis = null;
  VIS.emergency.untilMs = 0;
  VIS.emergency.amb = null;
}

/* =========================================================
   Lights (unchanged)
========================================================= */
function baseLightStateForAxis(axis, inter){
  if (!inter) return "red";
  if (!inter.in_transition) return (inter.phase === axis) ? "green" : "red";
  const tr = Number(inter.transition_left ?? 0);
  if (tr > ALL_RED_SEC) return "yellow";
  return "red";
}
function lightStateForAxis(axis, inter){
  if (VIS.emergency.active) return "red";
  return baseLightStateForAxis(axis, inter);
}
function isGreen(dir, inter) {
  if (VIS.emergency.active) return false;
  if (!inter) return false;
  if (inter.in_transition) return false;
  if ((dir === "N" || dir === "S") && inter.phase === "NS") return true;
  if ((dir === "E" || dir === "W") && inter.phase === "EW") return true;
  return false;
}

/* =========================================================
   ✅ Cars: WAITING then LEAVING (so no mid-disappear)
========================================================= */
function makeCar(dir, laneIndex) {
  return {
    type: "car",
    id: VIS.nextId++,
    dir,
    lane: 0,               // left lane only
    laneIndex,             // index among WAITING cars only
    state: "waiting",      // "waiting" | "leaving"
    tx: null, ty: null,    // used for leaving target
    x: 0, y: 0,
    color: pickCarColor()
  };
}

function waitingCars(dir){
  return VIS.cars[dir].filter(c => c.type === "car" && c.state === "waiting");
}
function leavingCars(dir){
  return VIS.cars[dir].filter(c => c.type === "car" && c.state === "leaving");
}

function markFrontCarLeaving(dir){
  // pick the front WAITING car (laneIndex 0)
  const w = waitingCars(dir).sort((a,b)=>a.laneIndex - b.laneIndex);
  if (w.length === 0) return;

  const c = w[0];
  c.state = "leaving";
  const ex = exitPoint(dir);
  c.tx = ex.x;
  c.ty = ex.y;

  // After removing the front one from "waiting", we must reindex the remaining waiting cars
  const rest = waitingCars(dir).filter(x => x.id !== c.id).sort((a,b)=>a.laneIndex-b.laneIndex);
  for (let i=0;i<rest.length;i++) rest[i].laneIndex = i;
}

function reconcileCars(inter) {
  if (!inter) return;

  const q = inter.queues;

  ["N","S","E","W"].forEach(dir => {
    const target = clamp(q[dir], 0, VIS.maxCarsPerDir);

    const lastQ = VIS.lastBackendQ[dir] ?? 0;

    // detect served drops (queue decreased)
    const drops = Math.max(0, lastQ - target);

    // for each served car: mark a FRONT car as leaving (do not delete)
    for (let k=0;k<drops;k++) markFrontCarLeaving(dir);

    // current waiting count after serving
    let wCount = waitingCars(dir).length;

    // if waiting < target, add new cars at the BACK
    while (wCount < target) {
      const c = makeCar(dir, wCount);
      placeCarAtBack(c);
      VIS.cars[dir].push(c);
      wCount++;
    }

    // if waiting > target (rare, e.g. reset), mark extras leaving from front
    while (wCount > target) {
      markFrontCarLeaving(dir);
      wCount = waitingCars(dir).length;
    }

    // store last backend queue
    VIS.lastBackendQ[dir] = target;
  });
}

/* =========================================================
   Movement with anti-overlap clamp (WAITING only)
   LEAVING cars go through to exit and disappear there
========================================================= */
function updateFlowOffset(dt, inter) {
  ["N","S","E","W"].forEach(dir => {
    if (isGreen(dir, inter)) VIS.flowOffset[dir] += VIS.passAdvance * dt;
    else {
      VIS.flowOffset[dir] *= 0.80;
      if (Math.abs(VIS.flowOffset[dir]) < 0.3) VIS.flowOffset[dir] = 0;
    }
    VIS.flowOffset[dir] = clamp(VIS.flowOffset[dir], 0, VIS.spacing);
  });
}

function targetPositionWaiting(dir, laneIndex) {
  const lane = 0;
  const stop = stopLine(dir, lane);
  let tx = stop.x, ty = stop.y;

  const off = VIS.flowOffset[dir];

  if (dir === "N") { ty -= laneIndex * VIS.spacing; ty += off; }
  if (dir === "S") { ty += laneIndex * VIS.spacing; ty -= off; }
  if (dir === "E") { tx += laneIndex * VIS.spacing; tx -= off; }
  if (dir === "W") { tx -= laneIndex * VIS.spacing; tx += off; }

  return {tx, ty};
}

function moveToward(car, tx, ty, speed, dt) {
  const dx = tx - car.x;
  const dy = ty - car.y;
  const d = Math.hypot(dx,dy) || 1;
  const step = Math.min(d, speed * dt);
  car.x += (dx/d) * step;
  car.y += (dy/d) * step;
}

// along travel axis (for clamp)
function axisPos(dir, car){
  if (dir === "N") return car.y;
  if (dir === "S") return -car.y;
  if (dir === "E") return -car.x;
  return car.x;
}

function updateCars(dt, inter) {
  if (!inter) return;

  updateFlowOffset(dt, inter);

  // WAITING cars: move to slots, then clamp no overlap
  ["N","S","E","W"].forEach(dir => {
    const w = waitingCars(dir).slice().sort((a,b)=>a.laneIndex-b.laneIndex);

    for (const c of w) {
      const {tx,ty} = targetPositionWaiting(dir, c.laneIndex);
      moveToward(c, tx, ty, VIS.followSpeed, dt);
    }

    // anti-overlap clamp for WAITING cars
    const minGap = VIS.spacing * 0.92;
    for (let i=1;i<w.length;i++){
      const front = w[i-1];
      const back  = w[i];

      const frontP = axisPos(dir, front);
      const backP  = axisPos(dir, back);

      if (backP > frontP - minGap) {
        const fix = backP - (frontP - minGap);

        if (dir === "N") back.y -= fix;
        if (dir === "S") back.y += fix;
        if (dir === "E") back.x += fix;
        if (dir === "W") back.x -= fix;
      }
    }

    // LEAVING cars: drive through to exit, then delete only at the far end
    const lv = leavingCars(dir);
    for (const c of lv) {
      if (c.tx == null || c.ty == null) {
        const ex = exitPoint(dir);
        c.tx = ex.x; c.ty = ex.y;
      }
      moveToward(c, c.tx, c.ty, VIS.passSpeed * (canvas.width/1000), dt);

      // remove only when it reaches the far end (NOT middle)
      if (Math.hypot(c.x - c.tx, c.y - c.ty) < 10) {
        VIS.cars[dir] = VIS.cars[dir].filter(x => x.id !== c.id);
      }
    }
  });

  // ambulance movement (unchanged)
  if (VIS.emergency.active && VIS.emergency.amb) {
    const amb = VIS.emergency.amb;
    const speed = 560 * (canvas.width/1000);

    const {W,H,cx,cy} = roadGeom();
    const farX = W*0.55, farY = H*0.55;

    let tx = amb.x, ty = amb.y;
    if (amb.dir === "N") { ty = cy + farY; }
    if (amb.dir === "S") { ty = cy - farY; }
    if (amb.dir === "E") { tx = cx - farX; }
    if (amb.dir === "W") { tx = cx + farX; }

    moveToward(amb, tx, ty, speed, dt);

    if (Math.hypot(amb.x-tx, amb.y-ty) < 8) endEmergency();
  }

  if (VIS.emergency.active && performance.now() > VIS.emergency.untilMs) endEmergency();
}

/* =========================================================
   Drawing (unchanged)
========================================================= */
function roundRect(c, x, y, w, h, r) {
  c.beginPath();
  c.moveTo(x+r, y);
  c.arcTo(x+w, y,   x+w, y+h, r);
  c.arcTo(x+w, y+h, x,   y+h, r);
  c.arcTo(x,   y+h, x,   y,   r);
  c.arcTo(x,   y,   x+w, y,   r);
  c.closePath();
}

function drawRoads() {
  const {W,H,cx,cy,roadW,laneSep,stopDist} = roadGeom();

  ctx.fillStyle = "#0b0f1a";
  ctx.fillRect(0,0,W,H);

  ctx.fillStyle = "#0e152c";
  ctx.strokeStyle = "rgba(120,150,240,0.25)";
  ctx.lineWidth = 2;

  ctx.beginPath();
  roundRect(ctx, cx - W*0.48, cy - roadW/2, W*0.96, roadW, 18);
  ctx.fill(); ctx.stroke();

  ctx.beginPath();
  roundRect(ctx, cx - roadW/2, cy - H*0.48, roadW, H*0.96, 18);
  ctx.fill(); ctx.stroke();

  ctx.setLineDash([10,10]);
  ctx.strokeStyle = "rgba(160,190,255,0.22)";
  ctx.lineWidth = 2;

  ctx.beginPath(); ctx.moveTo(cx - W*0.48, cy); ctx.lineTo(cx + W*0.48, cy); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(cx, cy - H*0.48); ctx.lineTo(cx, cy + H*0.48); ctx.stroke();

  ctx.beginPath(); ctx.moveTo(cx - W*0.48, cy - laneSep); ctx.lineTo(cx + W*0.48, cy - laneSep); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(cx - W*0.48, cy + laneSep); ctx.lineTo(cx + W*0.48, cy + laneSep); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(cx - laneSep, cy - H*0.48); ctx.lineTo(cx - laneSep, cy + H*0.48); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(cx + laneSep, cy - H*0.48); ctx.lineTo(cx + laneSep, cy + H*0.48); ctx.stroke();

  ctx.setLineDash([]);

  ctx.strokeStyle = "rgba(240,250,255,0.35)";
  ctx.lineWidth = 4;

  ctx.beginPath(); ctx.moveTo(cx-roadW/2, cy-stopDist); ctx.lineTo(cx+roadW/2, cy-stopDist); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(cx-roadW/2, cy+stopDist); ctx.lineTo(cx+roadW/2, cy+stopDist); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(cx-stopDist, cy-roadW/2); ctx.lineTo(cx-stopDist, cy+roadW/2); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(cx+stopDist, cy-roadW/2); ctx.lineTo(cx+stopDist, cy+roadW/2); ctx.stroke();
}

function drawLights(inter) {
  if (!inter) return;
  const {cx,cy,stopDist} = roadGeom();

  const nsState = lightStateForAxis("NS", inter);
  const ewState = lightStateForAxis("EW", inter);

  function colorFor(state){
    if (state === "green") return "#2dd05a";
    if (state === "yellow") return "#ffd166";
    return "#dc4646";
  }
  function bulb(x,y,state){
    ctx.fillStyle = colorFor(state);
    ctx.beginPath(); ctx.arc(x,y,12,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle="rgba(0,0,0,0.45)";
    ctx.lineWidth=2; ctx.stroke();
  }

  bulb(cx, cy - stopDist*0.72, nsState);
  bulb(cx, cy + stopDist*0.72, nsState);
  bulb(cx + stopDist*0.72, cy, ewState);
  bulb(cx - stopDist*0.72, cy, ewState);

  ctx.fillStyle="#e8eefc";
  ctx.font = `${Math.floor(16*(canvas.width/1000))}px system-ui`;
  if (VIS.emergency.active) ctx.fillText(`EMERGENCY ACTIVE (ALL RED)`, 18, 30);
  else ctx.fillText(`NS: ${nsState.toUpperCase()} | EW: ${ewState.toUpperCase()}`, 18, 30);
}

function drawVehicleSprite(v) {
  const w = VIS.carLen * (canvas.width/1000);
  const h = VIS.carWid * (canvas.width/1000);

  let ang = 0;
  if (v.dir === "N") ang = Math.PI/2;
  if (v.dir === "S") ang = -Math.PI/2;
  if (v.dir === "E") ang = Math.PI;
  if (v.dir === "W") ang = 0;

  ctx.save();
  ctx.translate(v.x, v.y);
  ctx.rotate(ang);

  ctx.fillStyle = "rgba(0,0,0,0.25)";
  roundRect(ctx, -w/2+2, -h/2+2, w, h, 5);
  ctx.fill();

  if (v.type === "ambulance") ctx.fillStyle = "#6b0f1a";
  else ctx.fillStyle = v.color;

  roundRect(ctx, -w/2, -h/2, w, h, 5);
  ctx.fill();

  ctx.fillStyle = "rgba(10,20,40,0.65)";
  roundRect(ctx, -w/2+6, -h/2+3, w-12, h-6, 3);
  ctx.fill();

  if (v.type === "ambulance") {
    ctx.fillStyle = "rgba(255,255,255,0.7)";
    roundRect(ctx, -w/2+6, -2, w-12, 4, 2);
    ctx.fill();
  }

  ctx.restore();
}

function drawCars() {
  ["N","S","E","W"].forEach(dir => {
    for (const car of VIS.cars[dir]) drawVehicleSprite(car);
  });
  if (VIS.emergency.active && VIS.emergency.amb) drawVehicleSprite(VIS.emergency.amb);
}

function renderFrame(ts) {
  resizeCanvasToDisplaySize();
  const dt = Math.min(0.05, (ts - VIS.lastTs) / 1000);
  VIS.lastTs = ts;

  drawRoads();
  if (VIS.inter) {
    updateCars(dt, VIS.inter);
    drawLights(VIS.inter);
    drawCars();
  }
  requestAnimationFrame(renderFrame);
}
requestAnimationFrame(renderFrame);

function updateFromBackend(intersectionSnapshot) {
  VIS.inter = intersectionSnapshot;
  reconcileCars(VIS.inter);
}

/* =========================================================
   API + UI (unchanged)
========================================================= */
async function api(method, path, body=null) {
  const opts = { method, headers: {"Content-Type":"application/json"} };
  if (body) opts.body = JSON.stringify(body);
  const res = await fetch(`${API}${path}`, opts);
  return await res.json();
}

function setButtonsForMode(){
  const dyn = (currentMode === "dynamic");
  document.getElementById("btnEmergency").disabled = !dyn;
  document.getElementById("btnPedNS").disabled = !dyn;
  document.getElementById("btnPedEW").disabled = !dyn;
}

async function tickOnce() {
  const data = await api("POST","/tick");
  const sim = (currentMode === "fixed") ? data.fixed : data.dynamic;

  const A = sim.intersections.find(x => x.id === "A") || sim.intersections[0];
  const q = A.queues;

  document.getElementById("status").textContent =
    `t=${sim.t}s | scenario=${sim.scenario} | running=${data.running}`;

  document.getElementById("badge").textContent = currentMode;
  document.getElementById("badge").className = "pill " + (currentMode==="dynamic" ? "green":"red");

  document.getElementById("phaseLine").textContent =
    `Phase: ${A.phase} | time left: ${A.time_left}s ${A.in_transition ? "(transition)" : ""}` +
    (A.in_transition ? ` | transition_left: ${A.transition_left ?? "-"}` : "");

  document.getElementById("reasonLine").textContent = `Reason: ${A.reason || "-"}`;

  document.getElementById("qN").textContent = `N-IN: ${q.N}`;
  document.getElementById("qS").textContent = `S-IN: ${q.S}`;
  document.getElementById("qE").textContent = `E-IN: ${q.E}`;
  document.getElementById("qW").textContent = `W-IN: ${q.W}`;

  updateFromBackend(A);
  setButtonsForMode();
}

function startLoop() {
  if (timer) return;
  timer = setInterval(tickOnce, 900);
}
function stopLoop() {
  if (!timer) return;
  clearInterval(timer);
  timer = null;
}

document.getElementById("btnStart").onclick = async () => {
  await api("POST","/control",{running:true});
  startLoop();
};

document.getElementById("btnPause").onclick = async () => {
  await api("POST","/control",{running:false});
  stopLoop();
  await tickOnce();
};

document.getElementById("btnReset").onclick = async () => {
  await api("POST","/control",{seed: 42});
  endEmergency();
  VIS.lastBackendQ = {N:0,S:0,E:0,W:0};
  VIS.cars = {N:[],S:[],E:[],W:[]};
  await tickOnce();
};

document.getElementById("mode").onchange = async (e) => {
  currentMode = e.target.value;
  endEmergency();
  await tickOnce();
};

document.getElementById("scenario").onchange = async (e) => {
  await api("POST","/control",{scenario: e.target.value});
  endEmergency();
  VIS.lastBackendQ = {N:0,S:0,E:0,W:0};
  VIS.cars = {N:[],S:[],E:[],W:[]};
  await tickOnce();
};

document.getElementById("autoEvents").onchange = async (e) => {
  await api("POST","/control",{auto_events: e.target.checked});
};

document.getElementById("btnEmergency").onclick = async () => {
  if (currentMode !== "dynamic") return;

  const axis = VIS.emergency.nextAxis;
  VIS.emergency.nextAxis = (axis === "NS") ? "EW" : "NS";

  const where = (axis === "NS") ? "N" : "E";
  await api("POST","/inject",{intersection_id:"A", kind:"emergency", where});

  beginEmergency(axis);
  await tickOnce();
};

document.getElementById("btnPedNS").onclick = async () => {
  if (currentMode !== "dynamic") return;
  await api("POST","/inject",{intersection_id:"A", kind:"ped", where:"NS"});
  await tickOnce();
};

document.getElementById("btnPedEW").onclick = async () => {
  if (currentMode !== "dynamic") return;
  await api("POST","/inject",{intersection_id:"A", kind:"ped", where:"EW"});
  await tickOnce();
};

(async () => {
  try {
    await api("GET","/health");
    await tickOnce();
  } catch(e) {
    document.getElementById("status").textContent = "Backend not running on 8000.";
  }
})();
</script>
</body>
</html>
